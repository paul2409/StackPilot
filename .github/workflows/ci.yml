# ==========================================================
# CI WORKFLOW — SINGLE SOURCE OF TRUTH (TEACHING VERSION)
#
# Goal:
# - ONE workflow file
# - If self-hosted runner is available:
#     → bring up VMs (via Makefile switch)
#     → run full verification (make verify)
#     → destroy lab (cleanup)
# - If self-hosted runner is NOT available:
#     → do NOT attempt VMs
#     → run repo checks only (make checks)
#
# Log rule:
# - All logs MUST be created under: ci/logs/
# - We capture stdout/stderr with `tee` so reviewers can read failures.
#
# Important reality:
# - GitHub chooses runners BEFORE steps run.
# - So we cannot "detect runner" inside the same job.
#
# What changed in this version (so you don't wait):
# - Hosted checks run ALWAYS and IMMEDIATELY (no dependency on self-hosted).
# - Self-hosted lab job is "best-effort":
#     • if runner exists, it runs
#     • if runner does not exist, it will sit queued, but it will NOT block your
#       hosted checks from completing or your PR from becoming mergeable
#       (as long as branch protection requires ONLY the hosted checks job).
#
# Phase 2 addition:
# - Hosted runners do not guarantee Terraform is installed.
# - We install Terraform explicitly so `make check-terraform` can run.
# ==========================================================

name: ci

# ----------------------------------------------------------
# Triggers:
# - pull_request: every PR gets validated
# - push to main: main stays protected/verified
# ----------------------------------------------------------
on:
  pull_request:
  push:
    branches: [ main ]

# ----------------------------------------------------------
# Permissions:
# - contents: read is enough to checkout the repo.
# - we are NOT using any API calls here, so no actions:read needed.
# ----------------------------------------------------------
permissions:
  contents: read

# ----------------------------------------------------------
# Concurrency (repo-level):
# - Prevents overlapping CI runs stepping on each other per ref.
# - If you push new commits quickly, older runs get cancelled.
#
# Note:
# - This is separate from "lab concurrency" below.
# ----------------------------------------------------------
concurrency:
  group: stackpilot-ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ======================================================
  # JOB 1 — HOSTED CHECKS (ALWAYS RUNS, NEVER WAITS)
  #
  # Runs on:
  # - GitHub-hosted runner ubuntu-latest
  #
  # When will this job run?
  # - ALWAYS (every PR/push), immediately.
  #
  # What does it do?
  # - Runs `make checks` only (no VM attempts)
  # - Saves output to ci/logs/checks.log
  #
  # Why do we do checks only here?
  # - Hosted runners cannot run your VirtualBox/Vagrant VMs.
  # - So we enforce repo correctness, not runtime correctness.
  #
  # Phase 1 rule (recommended):
  # - In branch protection, require THIS job to pass.
  # - Do NOT require the self-hosted lab job yet.
  # ======================================================
  checks_only:
    name: Hosted Checks (No VM Access)

    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v4

      # --------------------------------------------------
      # Phase 2 requirement:
      # - Terraform must exist on the runner for fmt/validate gates.
      # - This does NOT touch infra. It only installs the CLI binary.
      # --------------------------------------------------
      - name: Setup Terraform (Phase 2 gates)
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5

      # Run repo checks and capture logs
      - name: Repo checks (no VM access)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ci/logs
          make checks 2>&1 | tee ci/logs/checks.log

      # Upload logs even if checks fail
      - name: Upload checks logs (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: checks-logs
          path: ci/logs/
          if-no-files-found: warn
          retention-days: 14

  # ======================================================
  # JOB 2 — SELF-HOSTED LAB PATH (BEST-EFFORT)
  #
  # Runs on:
  # - a self-hosted runner that has label: stackpilot-vmhost
  #
  # When will this job run?
  # - Only when you have a self-hosted runner registered + online
  # - If you do not, GitHub will NOT be able to schedule it and it may remain queued.
  #
  # What does it do?
  # - Calls `CI_LAB_BOOTSTRAP=1 make verify`
  #   which (by your Makefile design) will:
  #     1) vm-up (bring up VMs) because CI_LAB_BOOTSTRAP=1
  #     2) run checks (policy/secrets/guarantees)
  #     3) run runtime verification (verify-host/cluster/build)
  # - Always destroys the lab afterward (cleanup guarantee).
  #
  # Why this does NOT block you anymore:
  # - Hosted checks run independently (no needs/if gate).
  # - Your PR can be mergeable based on hosted checks alone (Phase 1),
  #   even if this job is queued waiting for a runner.
  # ======================================================
  lab_full:
    name: Self-Hosted Lab (VM → Verify → Destroy)

    # This is the key:
    # - GitHub will only schedule this job on a runner that matches these labels.
    runs-on: [self-hosted, stackpilot-vmhost]

    # Allow more time because VM lifecycle can take time.
    timeout-minutes: 60

    # ----------------------------------------------------
    # Lab-level concurrency:
    # - Only ONE CI job is allowed to own the lab at a time.
    # - Without this, two CI runs could both try to boot/destroy the same VMs.
    # ----------------------------------------------------
    concurrency:
      group: stackpilot-lab
      cancel-in-progress: true

    # ----------------------------------------------------
    # continue-on-error:
    # - This is IMPORTANT for your design requirement.
    # - It prevents the overall workflow from being "hard-blocked" by lab failures.
    #
    # Note:
    # - You will still SEE a failure in this job if it actually runs and fails.
    # - This is "best-effort lab proof" until Phase 3 is fully enforced.
    # ----------------------------------------------------
    continue-on-error: true

    steps:
      # Pull the repo onto the runner.
      - uses: actions/checkout@v4

      # --------------------------------------------------
      # Phase 2 safety:
      # - Ensure Terraform exists on self-hosted too (idempotent).
      # - This keeps the job consistent across runners.
      # --------------------------------------------------
      - name: Setup Terraform (Phase 2 gates)
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5

      # --------------------------------------------------
      # The main step:
      # - Create ci/logs/ (your repo-root CI folder)
      # - Run make verify with VM bootstrap enabled
      # - Capture all output into ci/logs/verify.log
      #
      # Why tee?
      # - You see output live in Actions logs
      # - You also save it to a file for artifact upload
      #
      # Why set -euo pipefail?
      # - e: stop on first failure
      # - u: error on unset variables
      # - pipefail: if any command in a pipeline fails, the step fails
      # --------------------------------------------------
      - name: Full verification (boot lab then verify)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ci/logs
          CI_LAB_BOOTSTRAP=1 make verify 2>&1 | tee ci/logs/verify.log

      # --------------------------------------------------
      # Artifact upload:
      # - ALWAYS upload logs even if verify fails
      # - This is critical: failure must be inspectable.
      # --------------------------------------------------
      - name: Upload lab logs (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: lab-logs
          path: ci/logs/
          if-no-files-found: warn
          retention-days: 14

      # --------------------------------------------------
      # Cleanup:
      # - ALWAYS destroy the lab
      # - This prevents leaked VMs, stuck containers, stale state.
      # --------------------------------------------------
      - name: Destroy lab (always)
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          make destroy
