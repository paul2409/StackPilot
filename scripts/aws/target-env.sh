# scripts/aws/target-env.sh
#!/usr/bin/env bash
set -euo pipefail

# Purpose:
# - Generate artifacts/aws/target.env from Terraform outputs (CI-friendly)
# - No manual exports required afterwards

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
TF_DIR="$ROOT_DIR/infra/aws/tf"
OUT_DIR="$ROOT_DIR/artifacts/aws"
OUT_FILE="$OUT_DIR/target.env"

fail() { echo "FAIL: $*" >&2; exit 1; }

mkdir -p "$OUT_DIR"

command -v terraform >/dev/null 2>&1 || fail "terraform is required"

# Ensure TF outputs exist (apply was run)
if ! terraform -chdir="$TF_DIR" output >/dev/null 2>&1; then
  fail "terraform outputs not available. run: make deploy-aws (or terraform apply) first"
fi

# Pull raw outputs
TARGET_HOST="$(terraform -chdir="$TF_DIR" output -raw public_ip 2>/dev/null || true)"
PUBLIC_DNS="$(terraform -chdir="$TF_DIR" output -raw public_dns 2>/dev/null || true)"
API_PORT="$(terraform -chdir="$TF_DIR" output -raw api_port 2>/dev/null || true)"
SSH_USER="$(terraform -chdir="$TF_DIR" output -raw ssh_user 2>/dev/null || true)"

[[ -n "${API_PORT}" ]]    || fail "terraform output api_port is empty"
[[ -n "${SSH_USER}" ]]    || fail "terraform output ssh_user is empty"

# Prefer public_ip; fall back to public_dns if needed
if [[ -z "${TARGET_HOST}" ]]; then
  TARGET_HOST="${PUBLIC_DNS}"
fi
[[ -n "${TARGET_HOST}" ]] || fail "terraform output public_ip/public_dns is empty"

SSH_HOST="${TARGET_HOST}"
BASE_URL="http://${TARGET_HOST}:${API_PORT}"

# Write file (overwrite)
cat > "$OUT_FILE" <<EOF
# Generated by scripts/aws/target-env.sh
# Do not edit by hand.

TARGET_HOST=${TARGET_HOST}
SSH_HOST=${SSH_HOST}
SSH_USER=${SSH_USER}
API_PORT=${API_PORT}
BASE_URL=${BASE_URL}
EOF

echo "PASS: wrote: $OUT_FILE"
echo "TARGET_HOST=$TARGET_HOST"
echo "SSH_HOST=$SSH_HOST"
echo "SSH_USER=$SSH_USER"
echo "API_PORT=$API_PORT"
echo "BASE_URL=$BASE_URL"